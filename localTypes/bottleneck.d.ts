/** Declaration file generated by dts-gen */

export = bottleneck;

declare class bottleneck {
    constructor(maxNb: any, minTime: any, highWater: any, strategy: any, rejectOnDrop: any);

    Cluster(maxNb: any, minTime: any, highWater: any, strategy: any, rejectOnDrop: any): void;

    DLList(): void;

    Promise(executor: any): void;

    chain(limiter: any): any;

    changePenalty(penalty: any): any;

    changeReservoir(reservoir: any): any;

    changeSettings(maxNb: any, minTime: any, highWater: any, strategy: any, rejectOnDrop: any): any;

    check(): any;

    incrementReservoir(incr: any): any;

    isBlocked(): any;

    nbQueued(priority: any): any;

    nbRunning(): any;

    on(name: any, cb: any): any;

    removeAllListeners(name: any): any;

    schedule(...args: any[]): any;

    schedulePriority(...args: any[]): any;

    stopAll(interrupt: any, ...args: any[]): any;

    submit(...args: any[]): any;

    submitPriority(...args: any[]): any;

    static default: any;

    static strategy: {
        BLOCK: number;
        LEAK: number;
        OVERFLOW: number;
        OVERFLOW_PRIORITY: number;
    };

}

declare namespace bottleneck {
    class Cluster {
        constructor(maxNb: any, minTime: any, highWater: any, strategy: any, rejectOnDrop: any);

        all(cb: any): any;

        changeTimeout(timeout: any): any;

        deleteKey(key: any): any;

        key(key: any): any;

        keys(): any;

        startAutoCleanup(): any;

        stopAutoCleanup(): any;

    }

    class DLList {
        constructor();

        getArray(): any;

        push(value: any): void;

        shift(): any;

    }

    class Promise {
        constructor(executor: any);

        all(...args: any[]): any;

        any(): any;

        asCallback(nodeback: any, options: any): any;

        bind(thisArg: any): any;

        break(): any;

        call(methodName: any, ...args: any[]): any;

        cancel(): any;

        catch(fn: any, ...args: any[]): any;

        catchReturn(value: any, ...args: any[]): any;

        catchThrow(reason: any, ...args: any[]): any;

        caught(fn: any, ...args: any[]): any;

        delay(ms: any): any;

        disposer(fn: any): any;

        done(didFulfill: any, didReject: any): void;

        each(fn: any): any;

        error(fn: any): any;

        filter(fn: any, options: any): any;

        finally(handler: any): any;

        get(propertyName: any): any;

        isCancellable(): any;

        isCancelled(): any;

        isFulfilled(): any;

        isPending(): any;

        isRejected(): any;

        isResolved(): any;

        lastly(handler: any): any;

        map(fn: any, options: any): any;

        mapSeries(fn: any): any;

        nodeify(nodeback: any, options: any): any;

        props(): any;

        race(): any;

        reason(): any;

        reduce(fn: any, initialValue: any): any;

        reflect(): any;

        return(value: any): any;

        settle(): any;

        some(howMany: any): any;

        spread(fn: any): any;

        suppressUnhandledRejections(): void;

        tap(handler: any): any;

        tapCatch(handlerOrPredicate: any, ...args: any[]): any;

        then(didFulfill: any, didReject: any, ...args: any[]): any;

        thenReturn(value: any): any;

        thenThrow(reason: any): any;

        throw(reason: any): any;

        timeout(ms: any, message: any): any;

        toJSON(): any;

        toString(): any;

        value(): any;

        static Promise: any;

        static all(promises: any): any;

        static any(promises: any): any;

        static attempt(fn: any, ...args: any[]): any;

        static bind(thisArg: any, value: any): any;

        static cast(obj: any): any;

        static config(opts: any): any;

        static coroutine(generatorFunction: any, options: any, ...args: any[]): any;

        static defer(): any;

        static delay(ms: any, value: any): any;

        static each(promises: any, fn: any): any;

        static filter(promises: any, fn: any, options: any): any;

        static fromCallback(fn: any, ...args: any[]): any;

        static fromNode(fn: any, ...args: any[]): any;

        static fulfilled(obj: any): any;

        static getNewLibraryCopy(...args: any[]): any;

        static hasLongStackTraces(): any;

        static is(val: any): any;

        static join(...args: any[]): any;

        static longStackTraces(): void;

        static map(promises: any, fn: any, options: any, _filter: any): any;

        static mapSeries(promises: any, fn: any): any;

        static method(fn: any, ...args: any[]): any;

        static noConflict(): any;

        static onPossiblyUnhandledRejection(fn: any): void;

        static onUnhandledRejectionHandled(fn: any): void;

        static pending(): any;

        static promisify(fn: any, options: any): any;

        static promisifyAll(target: any, options: any): any;

        static props(promises: any): any;

        static race(promises: any): any;

        static reduce(promises: any, fn: any, initialValue: any, _each: any): any;

        static reject(reason: any): any;

        static rejected(reason: any): any;

        static resolve(obj: any): any;

        static setScheduler(fn: any): any;

        static settle(promises: any): any;

        static some(promises: any, howMany: any): any;

        static spawn(generatorFunction: any): any;

        static using(...args: any[]): any;

        static version: string;

    }

    namespace Cluster {
        namespace prototype {
            function all(cb: any): any;

            function changeTimeout(timeout: any): any;

            function deleteKey(key: any): any;

            function key(key: any): any;

            function keys(): any;

            function startAutoCleanup(): any;

            function stopAutoCleanup(): any;

            namespace all {
                const prototype: {
                };

            }

            namespace changeTimeout {
                const prototype: {
                };

            }

            namespace deleteKey {
                const prototype: {
                };

            }

            namespace key {
                const prototype: {
                };

            }

            namespace keys {
                const prototype: {
                };

            }

            namespace startAutoCleanup {
                const prototype: {
                };

            }

            namespace stopAutoCleanup {
                const prototype: {
                };

            }

        }

    }

    namespace DLList {
        namespace prototype {
            function getArray(): any;

            function push(value: any): void;

            function shift(): any;

            namespace getArray {
                const prototype: {
                };

            }

            namespace push {
                const prototype: {
                };

            }

            namespace shift {
                const prototype: {
                };

            }

        }

    }

    namespace Promise {
        class AggregateError {
            constructor(message: any);

            // Native method; no parameter or return type inference available
            constructor$(p0: any): any;

            // Native method; no parameter or return type inference available
            every(p0: any): any;

            // Native method; no parameter or return type inference available
            filter(p0: any): any;

            // Native method; no parameter or return type inference available
            forEach(p0: any): any;

            // Native method; no parameter or return type inference available
            indexOf(p0: any): any;

            // Native method; no parameter or return type inference available
            join(p0: any): any;

            // Native method; no parameter or return type inference available
            lastIndexOf(p0: any): any;

            // Native method; no parameter or return type inference available
            map(p0: any): any;

            // Native method; no parameter or return type inference available
            pop(): any;

            // Native method; no parameter or return type inference available
            push(p0: any): any;

            // Native method; no parameter or return type inference available
            reduce(p0: any): any;

            // Native method; no parameter or return type inference available
            reduceRight(p0: any): any;

            // Native method; no parameter or return type inference available
            reverse(): any;

            // Native method; no parameter or return type inference available
            shift(): any;

            // Native method; no parameter or return type inference available
            slice(p0: any, p1: any): any;

            // Native method; no parameter or return type inference available
            some(p0: any): any;

            // Native method; no parameter or return type inference available
            sort(p0: any): any;

            toString(): any;

            // Native method; no parameter or return type inference available
            unshift(p0: any): any;

        }

        class CancellationError {
            constructor(message: any);

            // Native method; no parameter or return type inference available
            constructor$(p0: any): any;

        }

        class OperationalError {
            constructor(message: any);

            // Native method; no parameter or return type inference available
            constructor$(p0: any): any;

        }

        class PromiseInspection {
            constructor(promise: any);

            error(): any;

            isCancelled(): any;

            isFulfilled(): any;

            isPending(): any;

            isRejected(): any;

            isResolved(): any;

            reason(): any;

            value(): any;

        }

        class RangeError {
            constructor(p0: any);

            // Native method; no parameter or return type inference available
            toString(): any;

            static captureStackTrace(p0: any, p1: any): any;

            static stackTraceLimit: number;

        }

        class RejectionError {
            constructor(message: any);

            // Native method; no parameter or return type inference available
            constructor$(p0: any): any;

        }

        class TimeoutError {
            constructor(message: any);

            // Native method; no parameter or return type inference available
            constructor$(p0: any): any;

        }

        class TypeError {
            constructor(p0: any);

            // Native method; no parameter or return type inference available
            toString(): any;

            static captureStackTrace(p0: any, p1: any): any;

            static stackTraceLimit: number;

        }

        namespace AggregateError {
            namespace prototype {
                class constructor$ {
                    constructor(p0: any);

                    // Native method; no parameter or return type inference available
                    toString(): any;

                    static captureStackTrace: any;

                    static prototype: any;

                    static stackTraceLimit: any;

                }

                const isOperational: boolean;

                const length: number;

                const message: string;

                const name: string;

                function every(p0: any): any;

                function filter(p0: any): any;

                function forEach(p0: any): any;

                function indexOf(p0: any): any;

                function join(p0: any): any;

                function lastIndexOf(p0: any): any;

                function map(p0: any): any;

                function pop(): any;

                function push(p0: any): any;

                function reduce(p0: any): any;

                function reduceRight(p0: any): any;

                function reverse(): any;

                function shift(): any;

                function slice(p0: any, p1: any): any;

                function some(p0: any): any;

                function sort(p0: any): any;

                function toString(): any;

                function unshift(p0: any): any;

                namespace toString {
                    // Too-deep object hierarchy from bottleneck.Promise.AggregateError.prototype.toString
                    const prototype: any;

                }

            }

        }

        namespace CancellationError {
            namespace prototype {
                class constructor$ {
                    constructor(p0: any);

                    // Native method; no parameter or return type inference available
                    toString(): any;

                    static captureStackTrace: any;

                    static prototype: any;

                    static stackTraceLimit: any;

                }

                const message: string;

                const name: string;

                function toString(): any;

            }

        }

        namespace OperationalError {
            namespace prototype {
                class constructor$ {
                    constructor(p0: any);

                    // Native method; no parameter or return type inference available
                    toString(): any;

                    static captureStackTrace: any;

                    static prototype: any;

                    static stackTraceLimit: any;

                }

                const message: string;

                const name: string;

                function toString(): any;

            }

        }

        namespace PromiseInspection {
            namespace prototype {
                function error(): any;

                function isCancelled(): any;

                function isFulfilled(): any;

                function isPending(): any;

                function isRejected(): any;

                function isResolved(): any;

                function reason(): any;

                function value(): any;

                namespace error {
                    // Too-deep object hierarchy from bottleneck.Promise.PromiseInspection.prototype.error
                    const prototype: any;

                }

                namespace isCancelled {
                    // Too-deep object hierarchy from bottleneck.Promise.PromiseInspection.prototype.isCancelled
                    const prototype: any;

                }

                namespace isFulfilled {
                    // Too-deep object hierarchy from bottleneck.Promise.PromiseInspection.prototype.isFulfilled
                    const prototype: any;

                }

                namespace isPending {
                    // Too-deep object hierarchy from bottleneck.Promise.PromiseInspection.prototype.isPending
                    const prototype: any;

                }

                namespace isRejected {
                    // Too-deep object hierarchy from bottleneck.Promise.PromiseInspection.prototype.isRejected
                    const prototype: any;

                }

                namespace isResolved {
                    // Too-deep object hierarchy from bottleneck.Promise.PromiseInspection.prototype.isResolved
                    const prototype: any;

                }

                namespace reason {
                    // Too-deep object hierarchy from bottleneck.Promise.PromiseInspection.prototype.reason
                    const prototype: any;

                }

                namespace value {
                    // Too-deep object hierarchy from bottleneck.Promise.PromiseInspection.prototype.value
                    const prototype: any;

                }

            }

        }

        namespace RangeError {
            namespace prototype {
                const message: string;

                const name: string;

                function toString(): any;

            }

        }

        namespace RejectionError {
            namespace prototype {
                class constructor$ {
                    constructor(p0: any);

                    // Native method; no parameter or return type inference available
                    toString(): any;

                    static captureStackTrace: any;

                    static prototype: any;

                    static stackTraceLimit: any;

                }

                const message: string;

                const name: string;

                function toString(): any;

            }

        }

        namespace TimeoutError {
            namespace prototype {
                class constructor$ {
                    constructor(p0: any);

                    // Native method; no parameter or return type inference available
                    toString(): any;

                    static captureStackTrace: any;

                    static prototype: any;

                    static stackTraceLimit: any;

                }

                const message: string;

                const name: string;

                function toString(): any;

            }

        }

        namespace TypeError {
            namespace prototype {
                const message: string;

                const name: string;

                function toString(): any;

            }

        }

        namespace all {
            const prototype: {
            };

        }

        namespace any {
            const prototype: {
            };

        }

        namespace attempt {
            const prototype: {
            };

        }

        namespace bind {
            const prototype: {
            };

        }

        namespace cast {
            const prototype: {
            };

        }

        namespace config {
            const prototype: {
            };

        }

        namespace coroutine {
            const prototype: {
            };

            function addYieldHandler(fn: any): void;

            namespace addYieldHandler {
                const prototype: {
                };

            }

        }

        namespace defer {
            const prototype: {
            };

        }

        namespace delay {
            const prototype: {
            };

        }

        namespace each {
            const prototype: {
            };

        }

        namespace filter {
            const prototype: {
            };

        }

        namespace fromCallback {
            const prototype: {
            };

        }

        namespace fromNode {
            const prototype: {
            };

        }

        namespace fulfilled {
            const prototype: {
            };

        }

        namespace getNewLibraryCopy {
            const prototype: {
            };

        }

        namespace hasLongStackTraces {
            const prototype: {
            };

        }

        namespace is {
            const prototype: {
            };

        }

        namespace join {
            const prototype: {
            };

        }

        namespace longStackTraces {
            const prototype: {
            };

        }

        namespace map {
            const prototype: {
            };

        }

        namespace mapSeries {
            const prototype: {
            };

        }

        namespace method {
            const prototype: {
            };

        }

        namespace noConflict {
            const prototype: {
            };

        }

        namespace onPossiblyUnhandledRejection {
            const prototype: {
            };

        }

        namespace onUnhandledRejectionHandled {
            const prototype: {
            };

        }

        namespace pending {
            const prototype: {
            };

        }

        namespace promisify {
            const prototype: {
            };

        }

        namespace promisifyAll {
            const prototype: {
            };

        }

        namespace props {
            const prototype: {
            };

        }

        namespace prototype {
            function all(...args: any[]): any;

            function any(): any;

            function asCallback(nodeback: any, options: any): any;

            function bind(thisArg: any): any;

            function call(methodName: any, ...args: any[]): any;

            function cancel(): any;

            function catchReturn(value: any, ...args: any[]): any;

            function catchThrow(reason: any, ...args: any[]): any;

            function caught(fn: any, ...args: any[]): any;

            function delay(ms: any): any;

            function disposer(fn: any): any;

            function done(didFulfill: any, didReject: any): void;

            function each(fn: any): any;

            function error(fn: any): any;

            function filter(fn: any, options: any): any;

            function get(propertyName: any): any;

            function isCancellable(): any;

            function isCancelled(): any;

            function isFulfilled(): any;

            function isPending(): any;

            function isRejected(): any;

            function isResolved(): any;

            function lastly(handler: any): any;

            function map(fn: any, options: any): any;

            function mapSeries(fn: any): any;

            function nodeify(nodeback: any, options: any): any;

            function props(): any;

            function race(): any;

            function reason(): any;

            function reduce(fn: any, initialValue: any): any;

            function reflect(): any;

            function settle(): any;

            function some(howMany: any): any;

            function spread(fn: any): any;

            function suppressUnhandledRejections(): void;

            function tap(handler: any): any;

            function tapCatch(handlerOrPredicate: any, ...args: any[]): any;

            function then(didFulfill: any, didReject: any, ...args: any[]): any;

            function thenReturn(value: any): any;

            function thenThrow(reason: any): any;

            function timeout(ms: any, message: any): any;

            function toJSON(): any;

            function toString(): any;

            function value(): any;

            namespace all {
                const prototype: {
                };

            }

            namespace any {
                const prototype: {
                };

            }

            namespace asCallback {
                const prototype: {
                };

            }

            namespace bind {
                const prototype: {
                };

            }

            namespace call {
                const prototype: {
                };

            }

            namespace cancel {
                const prototype: {
                };

            }

            namespace catchReturn {
                const prototype: {
                };

            }

            namespace catchThrow {
                const prototype: {
                };

            }

            namespace caught {
                const prototype: {
                };

            }

            namespace delay {
                const prototype: {
                };

            }

            namespace disposer {
                const prototype: {
                };

            }

            namespace done {
                const prototype: {
                };

            }

            namespace each {
                const prototype: {
                };

            }

            namespace error {
                const prototype: {
                };

            }

            namespace filter {
                const prototype: {
                };

            }

            namespace get {
                const prototype: {
                };

            }

            namespace isCancellable {
                const prototype: {
                };

            }

            namespace isCancelled {
                const prototype: {
                };

            }

            namespace isFulfilled {
                const prototype: {
                };

            }

            namespace isPending {
                const prototype: {
                };

            }

            namespace isRejected {
                const prototype: {
                };

            }

            namespace isResolved {
                const prototype: {
                };

            }

            namespace lastly {
                const prototype: {
                };

            }

            namespace map {
                const prototype: {
                };

            }

            namespace mapSeries {
                const prototype: {
                };

            }

            namespace nodeify {
                const prototype: {
                };

            }

            namespace props {
                const prototype: {
                };

            }

            namespace race {
                const prototype: {
                };

            }

            namespace reason {
                const prototype: {
                };

            }

            namespace reduce {
                const prototype: {
                };

            }

            namespace reflect {
                const prototype: {
                };

            }

            namespace settle {
                const prototype: {
                };

            }

            namespace some {
                const prototype: {
                };

            }

            namespace spread {
                const prototype: {
                };

            }

            namespace suppressUnhandledRejections {
                const prototype: {
                };

            }

            namespace tap {
                const prototype: {
                };

            }

            namespace tapCatch {
                const prototype: {
                };

            }

            namespace then {
                const prototype: {
                };

            }

            namespace thenReturn {
                const prototype: {
                };

            }

            namespace thenThrow {
                const prototype: {
                };

            }

            namespace timeout {
                const prototype: {
                };

            }

            namespace toJSON {
                const prototype: {
                };

            }

            namespace toString {
                const prototype: {
                };

            }

            namespace value {
                const prototype: {
                };

            }

        }

        namespace race {
            const prototype: {
            };

        }

        namespace reduce {
            const prototype: {
            };

        }

        namespace reject {
            const prototype: {
            };

        }

        namespace rejected {
            const prototype: {
            };

        }

        namespace resolve {
            const prototype: {
            };

        }

        namespace setScheduler {
            const prototype: {
            };

        }

        namespace settle {
            const prototype: {
            };

        }

        namespace some {
            const prototype: {
            };

        }

        namespace spawn {
            const prototype: {
            };

        }

        namespace using {
            const prototype: {
            };

        }

    }

    namespace prototype {
        class Cluster {
            constructor(maxNb: any, minTime: any, highWater: any, strategy: any, rejectOnDrop: any);

            all(cb: any): any;

            changeTimeout(timeout: any): any;

            deleteKey(key: any): any;

            key(key: any): any;

            keys(): any;

            startAutoCleanup(): any;

            stopAutoCleanup(): any;

        }

        class DLList {
            constructor();

            getArray(): any;

            push(value: any): void;

            shift(): any;

        }

        class Promise {
            constructor(executor: any);

            all(...args: any[]): any;

            any(): any;

            asCallback(nodeback: any, options: any): any;

            bind(thisArg: any): any;

            break(): any;

            call(methodName: any, ...args: any[]): any;

            cancel(): any;

            catch(fn: any, ...args: any[]): any;

            catchReturn(value: any, ...args: any[]): any;

            catchThrow(reason: any, ...args: any[]): any;

            caught(fn: any, ...args: any[]): any;

            delay(ms: any): any;

            disposer(fn: any): any;

            done(didFulfill: any, didReject: any): void;

            each(fn: any): any;

            error(fn: any): any;

            filter(fn: any, options: any): any;

            finally(handler: any): any;

            get(propertyName: any): any;

            isCancellable(): any;

            isCancelled(): any;

            isFulfilled(): any;

            isPending(): any;

            isRejected(): any;

            isResolved(): any;

            lastly(handler: any): any;

            map(fn: any, options: any): any;

            mapSeries(fn: any): any;

            nodeify(nodeback: any, options: any): any;

            props(): any;

            race(): any;

            reason(): any;

            reduce(fn: any, initialValue: any): any;

            reflect(): any;

            return(value: any): any;

            settle(): any;

            some(howMany: any): any;

            spread(fn: any): any;

            suppressUnhandledRejections(): void;

            tap(handler: any): any;

            tapCatch(handlerOrPredicate: any, ...args: any[]): any;

            then(didFulfill: any, didReject: any, ...args: any[]): any;

            thenReturn(value: any): any;

            thenThrow(reason: any): any;

            throw(reason: any): any;

            timeout(ms: any, message: any): any;

            toJSON(): any;

            toString(): any;

            value(): any;

            static Promise: any;

            static all(promises: any): any;

            static any(promises: any): any;

            static attempt(fn: any, ...args: any[]): any;

            static bind(thisArg: any, value: any): any;

            static cast(obj: any): any;

            static config(opts: any): any;

            static coroutine(generatorFunction: any, options: any, ...args: any[]): any;

            static defer(): any;

            static delay(ms: any, value: any): any;

            static each(promises: any, fn: any): any;

            static filter(promises: any, fn: any, options: any): any;

            static fromCallback(fn: any, ...args: any[]): any;

            static fromNode(fn: any, ...args: any[]): any;

            static fulfilled(obj: any): any;

            static getNewLibraryCopy(...args: any[]): any;

            static hasLongStackTraces(): any;

            static is(val: any): any;

            static join(...args: any[]): any;

            static longStackTraces(): void;

            static map(promises: any, fn: any, options: any, _filter: any): any;

            static mapSeries(promises: any, fn: any): any;

            static method(fn: any, ...args: any[]): any;

            static noConflict(): any;

            static onPossiblyUnhandledRejection(fn: any): void;

            static onUnhandledRejectionHandled(fn: any): void;

            static pending(): any;

            static promisify(fn: any, options: any): any;

            static promisifyAll(target: any, options: any): any;

            static props(promises: any): any;

            static race(promises: any): any;

            static reduce(promises: any, fn: any, initialValue: any, _each: any): any;

            static reject(reason: any): any;

            static rejected(reason: any): any;

            static resolve(obj: any): any;

            static setScheduler(fn: any): any;

            static settle(promises: any): any;

            static some(promises: any, howMany: any): any;

            static spawn(generatorFunction: any): any;

            static using(...args: any[]): any;

            static version: string;

        }

        const strategy: {
            BLOCK: number;
            LEAK: number;
            OVERFLOW: number;
            OVERFLOW_PRIORITY: number;
        };

        function chain(limiter: any): any;

        function changePenalty(penalty: any): any;

        function changeReservoir(reservoir: any): any;

        function changeSettings(maxNb: any, minTime: any, highWater: any, strategy: any, rejectOnDrop: any): any;

        function check(): any;

        function incrementReservoir(incr: any): any;

        function isBlocked(): any;

        function nbQueued(priority: any): any;

        function nbRunning(): any;

        function on(name: any, cb: any): any;

        function removeAllListeners(name: any): any;

        function schedule(...args: any[]): any;

        function schedulePriority(...args: any[]): any;

        function stopAll(interrupt: any, ...args: any[]): any;

        function submit(...args: any[]): any;

        function submitPriority(...args: any[]): any;

        namespace Cluster {
            namespace prototype {
                function all(cb: any): any;

                function changeTimeout(timeout: any): any;

                function deleteKey(key: any): any;

                function key(key: any): any;

                function keys(): any;

                function startAutoCleanup(): any;

                function stopAutoCleanup(): any;

                namespace all {
                    // Too-deep object hierarchy from bottleneck.prototype.Cluster.prototype.all
                    const prototype: any;

                }

                namespace changeTimeout {
                    // Too-deep object hierarchy from bottleneck.prototype.Cluster.prototype.changeTimeout
                    const prototype: any;

                }

                namespace deleteKey {
                    // Too-deep object hierarchy from bottleneck.prototype.Cluster.prototype.deleteKey
                    const prototype: any;

                }

                namespace key {
                    // Too-deep object hierarchy from bottleneck.prototype.Cluster.prototype.key
                    const prototype: any;

                }

                namespace keys {
                    // Too-deep object hierarchy from bottleneck.prototype.Cluster.prototype.keys
                    const prototype: any;

                }

                namespace startAutoCleanup {
                    // Too-deep object hierarchy from bottleneck.prototype.Cluster.prototype.startAutoCleanup
                    const prototype: any;

                }

                namespace stopAutoCleanup {
                    // Too-deep object hierarchy from bottleneck.prototype.Cluster.prototype.stopAutoCleanup
                    const prototype: any;

                }

            }

        }

        namespace DLList {
            namespace prototype {
                function getArray(): any;

                function push(value: any): void;

                function shift(): any;

                namespace getArray {
                    // Too-deep object hierarchy from bottleneck.prototype.DLList.prototype.getArray
                    const prototype: any;

                }

                namespace push {
                    // Too-deep object hierarchy from bottleneck.prototype.DLList.prototype.push
                    const prototype: any;

                }

                namespace shift {
                    // Too-deep object hierarchy from bottleneck.prototype.DLList.prototype.shift
                    const prototype: any;

                }

            }

        }

        namespace Promise {
            class AggregateError {
                constructor(message: any);

                // Native method; no parameter or return type inference available
                constructor$(p0: any): any;

                // Native method; no parameter or return type inference available
                every(p0: any): any;

                // Native method; no parameter or return type inference available
                filter(p0: any): any;

                // Native method; no parameter or return type inference available
                forEach(p0: any): any;

                // Native method; no parameter or return type inference available
                indexOf(p0: any): any;

                // Native method; no parameter or return type inference available
                join(p0: any): any;

                // Native method; no parameter or return type inference available
                lastIndexOf(p0: any): any;

                // Native method; no parameter or return type inference available
                map(p0: any): any;

                // Native method; no parameter or return type inference available
                pop(): any;

                // Native method; no parameter or return type inference available
                push(p0: any): any;

                // Native method; no parameter or return type inference available
                reduce(p0: any): any;

                // Native method; no parameter or return type inference available
                reduceRight(p0: any): any;

                // Native method; no parameter or return type inference available
                reverse(): any;

                // Native method; no parameter or return type inference available
                shift(): any;

                // Native method; no parameter or return type inference available
                slice(p0: any, p1: any): any;

                // Native method; no parameter or return type inference available
                some(p0: any): any;

                // Native method; no parameter or return type inference available
                sort(p0: any): any;

                toString(): any;

                // Native method; no parameter or return type inference available
                unshift(p0: any): any;

            }

            class CancellationError {
                constructor(message: any);

                // Native method; no parameter or return type inference available
                constructor$(p0: any): any;

            }

            class OperationalError {
                constructor(message: any);

                // Native method; no parameter or return type inference available
                constructor$(p0: any): any;

            }

            class PromiseInspection {
                constructor(promise: any);

                error(): any;

                isCancelled(): any;

                isFulfilled(): any;

                isPending(): any;

                isRejected(): any;

                isResolved(): any;

                reason(): any;

                value(): any;

            }

            class RangeError {
                constructor(p0: any);

                // Native method; no parameter or return type inference available
                toString(): any;

                static captureStackTrace(p0: any, p1: any): any;

                static stackTraceLimit: number;

            }

            class RejectionError {
                constructor(message: any);

                // Native method; no parameter or return type inference available
                constructor$(p0: any): any;

            }

            class TimeoutError {
                constructor(message: any);

                // Native method; no parameter or return type inference available
                constructor$(p0: any): any;

            }

            class TypeError {
                constructor(p0: any);

                // Native method; no parameter or return type inference available
                toString(): any;

                static captureStackTrace(p0: any, p1: any): any;

                static stackTraceLimit: number;

            }

            namespace AggregateError {
                namespace prototype {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.AggregateError.prototype
                    const constructor$: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.AggregateError.prototype
                    const every: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.AggregateError.prototype
                    const filter: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.AggregateError.prototype
                    const forEach: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.AggregateError.prototype
                    const indexOf: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.AggregateError.prototype
                    const isOperational: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.AggregateError.prototype
                    const join: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.AggregateError.prototype
                    const lastIndexOf: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.AggregateError.prototype
                    const length: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.AggregateError.prototype
                    const map: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.AggregateError.prototype
                    const message: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.AggregateError.prototype
                    const name: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.AggregateError.prototype
                    const pop: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.AggregateError.prototype
                    const push: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.AggregateError.prototype
                    const reduce: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.AggregateError.prototype
                    const reduceRight: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.AggregateError.prototype
                    const reverse: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.AggregateError.prototype
                    const shift: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.AggregateError.prototype
                    const slice: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.AggregateError.prototype
                    const some: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.AggregateError.prototype
                    const sort: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.AggregateError.prototype
                    const toString: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.AggregateError.prototype
                    const unshift: any;

                }

            }

            namespace CancellationError {
                namespace prototype {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.CancellationError.prototype
                    const constructor$: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.CancellationError.prototype
                    const message: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.CancellationError.prototype
                    const name: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.CancellationError.prototype
                    const toString: any;

                }

            }

            namespace OperationalError {
                namespace prototype {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.OperationalError.prototype
                    const constructor$: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.OperationalError.prototype
                    const message: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.OperationalError.prototype
                    const name: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.OperationalError.prototype
                    const toString: any;

                }

            }

            namespace PromiseInspection {
                namespace prototype {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.PromiseInspection.prototype
                    const error: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.PromiseInspection.prototype
                    const isCancelled: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.PromiseInspection.prototype
                    const isFulfilled: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.PromiseInspection.prototype
                    const isPending: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.PromiseInspection.prototype
                    const isRejected: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.PromiseInspection.prototype
                    const isResolved: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.PromiseInspection.prototype
                    const reason: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.PromiseInspection.prototype
                    const value: any;

                }

            }

            namespace RangeError {
                namespace prototype {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.RangeError.prototype
                    const message: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.RangeError.prototype
                    const name: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.RangeError.prototype
                    const toString: any;

                }

            }

            namespace RejectionError {
                namespace prototype {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.RejectionError.prototype
                    const constructor$: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.RejectionError.prototype
                    const message: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.RejectionError.prototype
                    const name: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.RejectionError.prototype
                    const toString: any;

                }

            }

            namespace TimeoutError {
                namespace prototype {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.TimeoutError.prototype
                    const constructor$: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.TimeoutError.prototype
                    const message: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.TimeoutError.prototype
                    const name: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.TimeoutError.prototype
                    const toString: any;

                }

            }

            namespace TypeError {
                namespace prototype {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.TypeError.prototype
                    const message: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.TypeError.prototype
                    const name: any;

                    // Too-deep object hierarchy from bottleneck.prototype.Promise.TypeError.prototype
                    const toString: any;

                }

            }

            namespace all {
                const prototype: {
                };

            }

            namespace any {
                const prototype: {
                };

            }

            namespace attempt {
                const prototype: {
                };

            }

            namespace bind {
                const prototype: {
                };

            }

            namespace cast {
                const prototype: {
                };

            }

            namespace config {
                const prototype: {
                };

            }

            namespace coroutine {
                const prototype: {
                };

                function addYieldHandler(fn: any): void;

                namespace addYieldHandler {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.coroutine.addYieldHandler
                    const prototype: any;

                }

            }

            namespace defer {
                const prototype: {
                };

            }

            namespace delay {
                const prototype: {
                };

            }

            namespace each {
                const prototype: {
                };

            }

            namespace filter {
                const prototype: {
                };

            }

            namespace fromCallback {
                const prototype: {
                };

            }

            namespace fromNode {
                const prototype: {
                };

            }

            namespace fulfilled {
                const prototype: {
                };

            }

            namespace getNewLibraryCopy {
                const prototype: {
                };

            }

            namespace hasLongStackTraces {
                const prototype: {
                };

            }

            namespace is {
                const prototype: {
                };

            }

            namespace join {
                const prototype: {
                };

            }

            namespace longStackTraces {
                const prototype: {
                };

            }

            namespace map {
                const prototype: {
                };

            }

            namespace mapSeries {
                const prototype: {
                };

            }

            namespace method {
                const prototype: {
                };

            }

            namespace noConflict {
                const prototype: {
                };

            }

            namespace onPossiblyUnhandledRejection {
                const prototype: {
                };

            }

            namespace onUnhandledRejectionHandled {
                const prototype: {
                };

            }

            namespace pending {
                const prototype: {
                };

            }

            namespace promisify {
                const prototype: {
                };

            }

            namespace promisifyAll {
                const prototype: {
                };

            }

            namespace props {
                const prototype: {
                };

            }

            namespace prototype {
                function all(...args: any[]): any;

                function any(): any;

                function asCallback(nodeback: any, options: any): any;

                function bind(thisArg: any): any;

                function call(methodName: any, ...args: any[]): any;

                function cancel(): any;

                function catchReturn(value: any, ...args: any[]): any;

                function catchThrow(reason: any, ...args: any[]): any;

                function caught(fn: any, ...args: any[]): any;

                function delay(ms: any): any;

                function disposer(fn: any): any;

                function done(didFulfill: any, didReject: any): void;

                function each(fn: any): any;

                function error(fn: any): any;

                function filter(fn: any, options: any): any;

                function get(propertyName: any): any;

                function isCancellable(): any;

                function isCancelled(): any;

                function isFulfilled(): any;

                function isPending(): any;

                function isRejected(): any;

                function isResolved(): any;

                function lastly(handler: any): any;

                function map(fn: any, options: any): any;

                function mapSeries(fn: any): any;

                function nodeify(nodeback: any, options: any): any;

                function props(): any;

                function race(): any;

                function reason(): any;

                function reduce(fn: any, initialValue: any): any;

                function reflect(): any;

                function settle(): any;

                function some(howMany: any): any;

                function spread(fn: any): any;

                function suppressUnhandledRejections(): void;

                function tap(handler: any): any;

                function tapCatch(handlerOrPredicate: any, ...args: any[]): any;

                function then(didFulfill: any, didReject: any, ...args: any[]): any;

                function thenReturn(value: any): any;

                function thenThrow(reason: any): any;

                function timeout(ms: any, message: any): any;

                function toJSON(): any;

                function toString(): any;

                function value(): any;

                namespace all {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.prototype.all
                    const prototype: any;

                }

                namespace any {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.prototype.any
                    const prototype: any;

                }

                namespace asCallback {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.prototype.asCallback
                    const prototype: any;

                }

                namespace bind {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.prototype.bind
                    const prototype: any;

                }

                namespace call {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.prototype.call
                    const prototype: any;

                }

                namespace cancel {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.prototype.cancel
                    const prototype: any;

                }

                namespace catchReturn {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.prototype.catchReturn
                    const prototype: any;

                }

                namespace catchThrow {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.prototype.catchThrow
                    const prototype: any;

                }

                namespace caught {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.prototype.caught
                    const prototype: any;

                }

                namespace delay {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.prototype.delay
                    const prototype: any;

                }

                namespace disposer {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.prototype.disposer
                    const prototype: any;

                }

                namespace done {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.prototype.done
                    const prototype: any;

                }

                namespace each {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.prototype.each
                    const prototype: any;

                }

                namespace error {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.prototype.error
                    const prototype: any;

                }

                namespace filter {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.prototype.filter
                    const prototype: any;

                }

                namespace get {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.prototype.get
                    const prototype: any;

                }

                namespace isCancellable {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.prototype.isCancellable
                    const prototype: any;

                }

                namespace isCancelled {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.prototype.isCancelled
                    const prototype: any;

                }

                namespace isFulfilled {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.prototype.isFulfilled
                    const prototype: any;

                }

                namespace isPending {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.prototype.isPending
                    const prototype: any;

                }

                namespace isRejected {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.prototype.isRejected
                    const prototype: any;

                }

                namespace isResolved {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.prototype.isResolved
                    const prototype: any;

                }

                namespace lastly {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.prototype.lastly
                    const prototype: any;

                }

                namespace map {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.prototype.map
                    const prototype: any;

                }

                namespace mapSeries {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.prototype.mapSeries
                    const prototype: any;

                }

                namespace nodeify {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.prototype.nodeify
                    const prototype: any;

                }

                namespace props {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.prototype.props
                    const prototype: any;

                }

                namespace race {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.prototype.race
                    const prototype: any;

                }

                namespace reason {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.prototype.reason
                    const prototype: any;

                }

                namespace reduce {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.prototype.reduce
                    const prototype: any;

                }

                namespace reflect {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.prototype.reflect
                    const prototype: any;

                }

                namespace settle {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.prototype.settle
                    const prototype: any;

                }

                namespace some {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.prototype.some
                    const prototype: any;

                }

                namespace spread {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.prototype.spread
                    const prototype: any;

                }

                namespace suppressUnhandledRejections {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.prototype.suppressUnhandledRejections
                    const prototype: any;

                }

                namespace tap {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.prototype.tap
                    const prototype: any;

                }

                namespace tapCatch {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.prototype.tapCatch
                    const prototype: any;

                }

                namespace then {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.prototype.then
                    const prototype: any;

                }

                namespace thenReturn {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.prototype.thenReturn
                    const prototype: any;

                }

                namespace thenThrow {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.prototype.thenThrow
                    const prototype: any;

                }

                namespace timeout {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.prototype.timeout
                    const prototype: any;

                }

                namespace toJSON {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.prototype.toJSON
                    const prototype: any;

                }

                namespace toString {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.prototype.toString
                    const prototype: any;

                }

                namespace value {
                    // Too-deep object hierarchy from bottleneck.prototype.Promise.prototype.value
                    const prototype: any;

                }

            }

            namespace race {
                const prototype: {
                };

            }

            namespace reduce {
                const prototype: {
                };

            }

            namespace reject {
                const prototype: {
                };

            }

            namespace rejected {
                const prototype: {
                };

            }

            namespace resolve {
                const prototype: {
                };

            }

            namespace setScheduler {
                const prototype: {
                };

            }

            namespace settle {
                const prototype: {
                };

            }

            namespace some {
                const prototype: {
                };

            }

            namespace spawn {
                const prototype: {
                };

            }

            namespace using {
                const prototype: {
                };

            }

        }

        namespace chain {
            const prototype: {
            };

        }

        namespace changePenalty {
            const prototype: {
            };

        }

        namespace changeReservoir {
            const prototype: {
            };

        }

        namespace changeSettings {
            const prototype: {
            };

        }

        namespace check {
            const prototype: {
            };

        }

        namespace incrementReservoir {
            const prototype: {
            };

        }

        namespace isBlocked {
            const prototype: {
            };

        }

        namespace nbQueued {
            const prototype: {
            };

        }

        namespace nbRunning {
            const prototype: {
            };

        }

        namespace on {
            const prototype: {
            };

        }

        namespace removeAllListeners {
            const prototype: {
            };

        }

        namespace schedule {
            const prototype: {
            };

        }

        namespace schedulePriority {
            const prototype: {
            };

        }

        namespace stopAll {
            const prototype: {
            };

        }

        namespace submit {
            const prototype: {
            };

        }

        namespace submitPriority {
            const prototype: {
            };

        }

    }

}

